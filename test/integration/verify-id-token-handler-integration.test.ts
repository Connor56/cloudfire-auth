import { describe, it, expect, afterAll } from "vitest";
import { verifyIdTokenHandler } from "../../src/rest-api/verify-id-token.js";
import { getOauth2AccessTokenHandler } from "../../src/google-auth/get-oauth-2-token.js";
import serviceAccountKey from "../service-account-key.json";
import { env } from "process";
import { config } from "dotenv";
import { KVNamespace } from "@cloudflare/workers-types";
import { SignJWT, generateKeyPair } from "jose";

config({ path: "test/.env" });

/**
 * Creates a mock KV namespace for testing purposes.
 * @returns A mock KV namespace.
 */
function createMockKV() {
  const store = new Map();
  return {
    async get(key) {
      return store.get(key) ?? null;
    },
    async put(key, value) {
      store.set(key, value);
    },
    async delete(key) {
      store.delete(key);
    },
  };
}

const doNotRunIntegrationTests = env.RUN_INTEGRATION_TESTS !== "true";

describe.skipIf(doNotRunIntegrationTests)("Verify ID Token Handler Integration Tests", async () => {
  // Mocked namespace
  const KV_NAMESPACE = createMockKV() as KVNamespace;

  const oauth2Token = await getOauth2AccessTokenHandler(serviceAccountKey, 3000, KV_NAMESPACE);

  it("The KV namespace should have an oauth2 token", async () => {
    expect(await KV_NAMESPACE.get("oauth2Token")).toBeDefined();
    expect(await KV_NAMESPACE.get("oauth2Token")).toBe(oauth2Token);
  });

  const oauth2TokenFromKV = (await KV_NAMESPACE.get("oauth2Token")) as string;

  // Create a new user
  const tokenData = await addANewUserWithSignUp(oauth2TokenFromKV);

  const signInData = await signInWithPassword(oauth2TokenFromKV);

  it("The token generated by signInWithPassword should be verified", async () => {
    const decodedToken = await verifyIdTokenHandler(
      signInData.idToken,
      env.PROJECT_ID || "",
      oauth2TokenFromKV,
      KV_NAMESPACE,
      false
    );

    console.log("The decoded token is:", decodedToken);

    expect(decodedToken).toBeDefined();
    expect(decodedToken.name).toBe("test-user-123");
    expect(decodedToken.iss).toContain(serviceAccountKey.project_id);
    expect(decodedToken.email).toBe("test-user-123@example.com");
    expect(decodedToken.email_verified).toBe(false);
  }, 10000);

  it("Should reject fake tokens created with jose", async () => {
    // Test with various fake tokens created using jose library
    const fakeTokens = await createFakeTokens();

    for (const { token, description } of fakeTokens) {
      try {
        await verifyIdTokenHandler(token, env.PROJECT_ID || "", oauth2TokenFromKV, KV_NAMESPACE, false);
        // If we reach here, the test should fail because we expected an error
        expect.fail(`Expected token verification to fail for: ${description}`);
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        console.log(`✓ Correctly rejected ${description}: ${error.message}`);
      }
    }
  }, 15000);

  it("Should reject an outdated JWT token", async () => {
    // This is the legitimate but outdated JWT from the commented unit test
    const outdatedToken = env.OUTDATED_JWT || "";

    console.log("outdatedToken", outdatedToken);

    try {
      await verifyIdTokenHandler(outdatedToken, env.PROJECT_ID || "", oauth2TokenFromKV, KV_NAMESPACE, false);
      expect.fail("Expected outdated token verification to fail");
    } catch (error) {
      expect(error).toBeInstanceOf(Error);
      // Could fail due to expiration, wrong audience, or invalid signature
      console.log("✓ Correctly rejected outdated token:", error.message);
    }
  }, 10000);

  it("Should reject tokens after user refresh tokens are revoked", async () => {
    // Now revoke the user's refresh tokens
    console.log("revoking user refresh tokens for", tokenData);
    await revokeUserRefreshTokens(tokenData.localId, oauth2TokenFromKV);

    // Now the token should be rejected when checkRevoked=true
    try {
      await verifyIdTokenHandler(
        signInData.idToken,
        env.PROJECT_ID || "",
        oauth2TokenFromKV,
        KV_NAMESPACE,
        true // checkRevoked = true
      );
      expect.fail("Expected revoked token verification to fail");
    } catch (error) {
      expect(error).toBeInstanceOf(Error);
      expect(error.message).toBe("Token is revoked");
      console.log("✓ Correctly rejected revoked token");
    }
  }, 20000);

  it("Should reject tokens with wrong project ID in audience", async () => {
    // Use a valid token but wrong project ID
    try {
      await verifyIdTokenHandler(signInData.idToken, "wrong-project-id", oauth2TokenFromKV, KV_NAMESPACE, false);
      expect.fail("Expected token with wrong project ID to fail");
    } catch (error) {
      expect(error).toBeInstanceOf(Error);
      expect(error.message).toContain("Token audience does not match project ID");
      console.log("✓ Correctly rejected token with wrong project ID");
    }
  }, 10000);

  afterAll(async () => {
    await deleteUser(tokenData.localId, oauth2TokenFromKV);
  });
});

/**
 * Creates a new user with a password and email sign up flow.
 * @param oauth2Token - The OAuth2 token for the Firebase Admin API.
 * @returns The custom token for the user.
 */
async function addANewUserWithSignUp(oauth2Token: string) {
  const response = await fetch("https://identitytoolkit.googleapis.com/v1/accounts:signUp", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${oauth2Token}`,
    },
    body: JSON.stringify({
      email: "test-user-123@example.com",
      password: "password",
      displayName: "test-user-123",
    }),
  });

  const data = await response.json();

  return data;
}

/**
 * Signs in a user with email and password.
 * @param oauth2Token - The OAuth2 token for the Firebase Admin API.
 * @returns The sign in response data including idToken.
 */
async function signInWithPassword(oauth2Token: string) {
  const response = await fetch("https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${oauth2Token}`,
    },
    body: JSON.stringify({
      email: "test-user-123@example.com",
      password: "password",
      returnSecureToken: true,
    }),
  });

  const data = await response.json();

  return data;
}

/**
 * Deletes a user from the Firebase Auth database.
 * @param localId - The local ID of the user to delete.
 */
async function deleteUser(localId: string, oauth2Token: string) {
  const response = await fetch("https://identitytoolkit.googleapis.com/v1/accounts:delete", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${oauth2Token}`,
    },
    body: JSON.stringify({
      localId: localId,
    }),
  });
}

/**
 * Creates various fake JWT tokens for testing token validation failures.
 * @returns Array of fake tokens with descriptions
 */
async function createFakeTokens(): Promise<Array<{ token: string; description: string }>> {
  const { publicKey, privateKey } = await generateKeyPair("RS256");
  const currentTime = Math.floor(Date.now() / 1000);
  const projectId = env.PROJECT_ID || "test-project";

  const tokens: Array<{ token: string; description: string }> = [];

  // 1. Token with wrong algorithm (HS256 instead of RS256)
  try {
    const wrongAlgToken = await new SignJWT({
      iss: `https://securetoken.google.com/${projectId}`,
      aud: projectId,
      sub: "test-user",
      iat: currentTime,
      exp: currentTime + 3600,
      auth_time: currentTime,
    })
      .setProtectedHeader({ alg: "HS256", kid: "fake-key-id" })
      .sign(new TextEncoder().encode("fake-secret"));
    tokens.push({ token: wrongAlgToken, description: "Token with wrong algorithm (HS256)" });
  } catch (e) {
    // Skip if we can't create HS256 token
  }

  // 2. Token with wrong issuer
  const wrongIssuerToken = await new SignJWT({
    iss: "https://evil.com",
    aud: projectId,
    sub: "test-user",
    iat: currentTime,
    exp: currentTime + 3600,
    auth_time: currentTime,
  })
    .setProtectedHeader({ alg: "RS256", kid: "fake-key-id" })
    .sign(privateKey);
  tokens.push({ token: wrongIssuerToken, description: "Token with wrong issuer" });

  // 3. Token with wrong audience
  const wrongAudToken = await new SignJWT({
    iss: `https://securetoken.google.com/${projectId}`,
    aud: "wrong-project-id",
    sub: "test-user",
    iat: currentTime,
    exp: currentTime + 3600,
    auth_time: currentTime,
  })
    .setProtectedHeader({ alg: "RS256", kid: "fake-key-id" })
    .sign(privateKey);
  tokens.push({ token: wrongAudToken, description: "Token with wrong audience" });

  // 4. Expired token
  const expiredToken = await new SignJWT({
    iss: `https://securetoken.google.com/${projectId}`,
    aud: projectId,
    sub: "test-user",
    iat: currentTime - 7200, // 2 hours ago
    exp: currentTime - 3600, // expired 1 hour ago
    auth_time: currentTime - 7200,
  })
    .setProtectedHeader({ alg: "RS256", kid: "fake-key-id" })
    .sign(privateKey);
  tokens.push({ token: expiredToken, description: "Expired token" });

  // 5. Token with future iat (issued at time)
  const futureIatToken = await new SignJWT({
    iss: `https://securetoken.google.com/${projectId}`,
    aud: projectId,
    sub: "test-user",
    iat: currentTime + 3600, // 1 hour in the future
    exp: currentTime + 7200,
    auth_time: currentTime,
  })
    .setProtectedHeader({ alg: "RS256", kid: "fake-key-id" })
    .sign(privateKey);
  tokens.push({ token: futureIatToken, description: "Token with future issued-at time" });

  // 6. Token with empty subject
  const emptySubToken = await new SignJWT({
    iss: `https://securetoken.google.com/${projectId}`,
    aud: projectId,
    sub: "", // empty subject
    iat: currentTime,
    exp: currentTime + 3600,
    auth_time: currentTime,
  })
    .setProtectedHeader({ alg: "RS256", kid: "fake-key-id" })
    .sign(privateKey);
  tokens.push({ token: emptySubToken, description: "Token with empty subject" });

  // 7. Token with invalid key ID (will fail signature verification)
  const invalidKeyToken = await new SignJWT({
    iss: `https://securetoken.google.com/${projectId}`,
    aud: projectId,
    sub: "test-user",
    iat: currentTime,
    exp: currentTime + 3600,
    auth_time: currentTime,
  })
    .setProtectedHeader({ alg: "RS256", kid: "non-existent-key-id" })
    .sign(privateKey);
  tokens.push({ token: invalidKeyToken, description: "Token signed with unknown private key" });

  return tokens;
}

/**
 * Revokes all refresh tokens for a user, making their existing ID tokens invalid
 * when checkRevoked=true is used.
 * @param localId - The local ID of the user
 * @param oauth2Token - The OAuth2 token for the Firebase Admin API
 */
async function revokeUserRefreshTokens(localId: string, oauth2Token: string): Promise<void> {
  const newValidSince = Math.floor(Date.now() / 1000).toString();
  console.log("revoking user refresh tokens for", localId, "with new validSince", newValidSince);
  const response = await fetch("https://identitytoolkit.googleapis.com/v1/accounts:update", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${oauth2Token}`,
    },
    body: JSON.stringify({
      localId: localId,
      validSince: newValidSince,
    }),
  });

  if (!response.ok) {
    throw new Error(`Failed to revoke tokens: ${response.status} ${response.statusText}, ${await response.text()}`);
  }
}
